<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>18.3&nbsp;Representation of Caml data types</title><link rel="stylesheet" href="css/stylesheet.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="The Objective Caml system release 3.12"><link rel="up" href="ch18.html" title="18.&nbsp;C と Objective Caml のインタフェース"><link rel="prev" href="ch18s02.html" title="18.2&nbsp;The value type"><link rel="next" href="ch18s04.html" title="18.4&nbsp;Operations on values"></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">18.3&nbsp;Representation of Caml data types</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch18s02.html">前のページ</a>&nbsp;</td><th width="60%" align="center">18.&nbsp;C と Objective Caml のインタフェース</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch18s04.html">次のページ</a></td></tr></table><hr></div><div class="section" title="18.3&nbsp;Representation of Caml data types"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e13503"></a>18.3&nbsp;Representation of Caml data types</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch18s03.html#d4e13506">18.3.1. Atomic types</a></span></dt><dt><span class="section"><a href="ch18s03.html#d4e13535">18.3.2. Tuples and records</a></span></dt><dt><span class="section"><a href="ch18s03.html#d4e13540">18.3.3. Arrays</a></span></dt><dt><span class="section"><a href="ch18s03.html#d4e13544">18.3.4. Concrete types</a></span></dt><dt><span class="section"><a href="ch18s03.html#d4e13569">18.3.5. Objects</a></span></dt><dt><span class="section"><a href="ch18s03.html#d4e13574">18.3.6. Variants</a></span></dt></dl></div>
    
    <p>
      This section describes how Caml data types are encoded in the value type.
    </p>
    <div class="section" title="18.3.1&nbsp;Atomic types"><div class="titlepage"><div><div><h3 class="title"><a name="d4e13506"></a>18.3.1&nbsp;Atomic types</h3></div></div></div>
      
      <table id="d4e13508">
        <thead>
          <tr><th>Caml type</th><th>              Encoding              </th></tr>
        </thead>
        <tbody>
          <tr><td>int</td><td>Unboxed integer values.</td></tr>
          <tr><td>char</td><td>Unboxed integer values (ASCII code).</td></tr>
          <tr><td>float</td><td>Blocks with tag Double_tag.</td></tr>
          <tr><td>string</td><td>Blocks with tag String_tag.</td></tr>
          <tr><td>int32</td><td>Blocks with tag Custom_tag.</td></tr>
          <tr><td>int64</td><td>Blocks with tag Custom_tag.</td></tr>
          <tr><td>nativeint</td><td>Blocks with tag Custom_tag.</td></tr>
      </tbody></table>
    </div>
    <div class="section" title="18.3.2&nbsp;Tuples and records"><div class="titlepage"><div><div><h3 class="title"><a name="d4e13535"></a>18.3.2&nbsp;Tuples and records</h3></div></div></div>
      
      <p>
        Tuples are represented by pointers to blocks, with tag 0.
      </p>
      <p>
        Records are also represented by zero-tagged blocks. The ordering of labels in
        the record type declaration determines the layout of the record fields: the
        value associated to the label declared first is stored in field 0 of the block,
        the value associated to the label declared next goes in field 1, and so on.
      </p>
      <p>
        As an optimization, records whose fields all have static type float are
        represented as arrays of floating-point numbers, with tag Double_array_tag.
        (See the section below on arrays.)
      </p>
    </div>
    <div class="section" title="18.3.3&nbsp;Arrays"><div class="titlepage"><div><div><h3 class="title"><a name="d4e13540"></a>18.3.3&nbsp;Arrays</h3></div></div></div>
      
      <p>
        Arrays of integers and pointers are represented like tuples,  that is, as
        pointers to blocks tagged 0. They are accessed with the Field macro for reading
        and the modify function for writing.
      </p>
      <p>
        Arrays of floating-point numbers (type float array) have a special, unboxed,
        more efficient representation. These arrays are represented by pointers to
        blocks with tag Double_array_tag. They should be accessed with the Double_field
        and Store_double_field macros.
      </p>
    </div>
    <div class="section" title="18.3.4&nbsp;Concrete types"><div class="titlepage"><div><div><h3 class="title"><a name="d4e13544"></a>18.3.4&nbsp;Concrete types</h3></div></div></div>
      
      <p>
        Constructed terms are represented either by unboxed integers (for constant
        constructors) or by blocks whose tag encode the constructor (for non-constant
        constructors). The constant constructors and the non-constant constructors for
        a given concrete type are numbered separately, starting from 0, in the order in
        which they appear in the concrete type declaration. Constant constructors are
        represented by unboxed integers equal to the constructor number. Non-constant
        constructors declared with a n-tuple as argument are represented by a block of
        size n, tagged with the constructor number; the n fields contain the components
        of its tuple argument. Other non-constant constructors are represented by a
        block of size 1, tagged with the constructor number; the field 0 contains the
        value of the constructor argument. Example:
      </p>
      <table id="d4e13547">
        <thead>
          <tr><th>Constructed term</th><th>    Representation     </th></tr>
        </thead>
        <tbody>
          <tr><td>()</td><td>Val_int(0)</td></tr>
          <tr><td>false</td><td>Val_int(0)</td></tr>
          <tr><td>true</td><td>Val_int(1)</td></tr>
          <tr><td>[]</td><td>Val_int(0)</td></tr>
          <tr><td>h::t</td><td>Block with size = 2 and tag = 0; first field contains h, second field t</td></tr>
      </tbody></table>
      <p>
        As a convenience, caml/mlvalues.h defines the macros Val_unit, Val_false and
        Val_true to refer to (), false and true.
      </p>
    </div>
    <div class="section" title="18.3.5&nbsp;Objects"><div class="titlepage"><div><div><h3 class="title"><a name="d4e13569"></a>18.3.5&nbsp;Objects</h3></div></div></div>
      
      <p>
        Objects are represented as blocks with tag Object_tag. The first field of the
        block refers to the object class and associated method suite, in a format that
        cannot easily be exploited from C. The second field contains a unique object
        ID, used for comparisons. The remaining fields of the object contain the values
        of the instance variables of the object. It is unsafe to access directly
        instance variables, as the type system provides no guaranteee about the
        instance variables contained by an object. 
      </p>
      <p>
        One may extract a public method from an object using the C function
        caml_get_public_method (declared in &lt;caml/mlvalues.h&gt;.) Since public method
        tags are hashed in the same way as variant tags, and methods are functions
        taking self as first argument, if you want to do the method call foo#bar from
        the C side, you should call: 
      </p>
      <pre class="programlisting">
  callback(caml_get_public_method(foo, hash_variant("bar")), foo);
</pre>
    </div>
    <div class="section" title="18.3.6&nbsp;Variants"><div class="titlepage"><div><div><h3 class="title"><a name="d4e13574"></a>18.3.6&nbsp;Variants</h3></div></div></div>
      
      <p>
        Like constructed terms, values of variant types are represented either as
        integers (for variants without arguments), or as blocks (for variants with an
        argument). Unlike constructed terms, variant constructors are not numbered
        starting from 0, but identified by a hash value (a Caml integer), as computed
        by the C function hash_variant (declared in &lt;caml/mlvalues.h&gt;): the hash value
        for a variant constructor named, say, VConstr is hash_variant("VConstr").
      </p>
      <p>
        The variant value `VConstr is represented by hash_variant("VConstr"). The
        variant value `VConstr(v) is represented by a block of size 2 and tag 0, with
        field number 0 containing hash_variant("VConstr") and field number 1 containing
        v.
      </p>
      <p>
        Unlike constructed values, variant values taking several arguments are not
        flattened. That is, `VConstr(v, v') is represented by a block of size 2, whose
        field number 1 contains the representation of the pair (v, v'), rather than a
        block of size 3 containing v and v' in fields 1 and 2.
      </p>
    </div>
  </div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch18s02.html">前のページ</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch18.html">上に戻る</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch18s04.html">次のページ</a></td></tr><tr><td width="40%" align="left" valign="top">18.2&nbsp;The value type&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top">&nbsp;18.4&nbsp;Operations on values</td></tr></table></div></body></html>