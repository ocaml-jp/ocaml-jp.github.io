<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>1.2&nbsp;データ型</title><link rel="stylesheet" href="css/stylesheet.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="The Objective Caml system release 3.12"><link rel="up" href="ch01.html" title="1.&nbsp;The core language"><link rel="prev" href="ch01s01.html" title="1.1&nbsp;基本"><link rel="next" href="ch01s03.html" title="1.3&nbsp;値としての関数"></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1.2&nbsp;データ型 </th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch01s01.html">前のページ</a>&nbsp;</td><th width="60%" align="center">1.&nbsp;The core language</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch01s03.html">次のページ</a></td></tr></table><hr></div><div class="section" title="1.2&nbsp;データ型"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Data types"></a>1.2&nbsp;データ型 </h2></div></div></div>
    
    <p>
      整数と浮動小数点数以外に、Caml には真偽値、文字、文字列の基本型があります。 
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>(1 &lt; 2) = false;;</code></strong>
<code class="computeroutput">- : bool = false</code>

<code class="prompt">#</code><strong class="userinput"><code>'a';;</code></strong>
<code class="computeroutput">- : char = 'a'</code>

<code class="prompt">#</code><strong class="userinput"><code>"Hello world";;</code></strong>
<code class="computeroutput">- : string = "Hello world"</code>
    </pre>
    <p>
      あらかじめ定義されているデータ構造として、タプル、配列、リストがあります。ユーザが自分でデータ構造を定義することも出来ます。ユーザー定義型については後で説明することにして、今はリストに集中しましょう。
      リストは要素をセミコロンで区切りブラケットで囲んだ形で書くか、空リスト <code class="code">[]</code> （nil と発音します）の前に <code class="code">::</code> （cons）演算子で要素を加える形で書くことが出来ます。 
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>let l = ["is"; "a"; "tale"; "told"; "etc."];;</code></strong>
<code class="computeroutput">val l : string list = ["is"; "a"; "tale"; "told"; "etc."]</code>

<code class="prompt">#</code><strong class="userinput"><code>"Life" :: l;;</code></strong>
<code class="computeroutput">- : string list = ["Life"; "is"; "a"; "tale"; "told"; "etc."]</code>
    </pre>
    <p>
      他の Caml のデータ構造と同じく、リストに関してメモリの確保・開放を自分でする必要はありません。メモリ管理はすべて自動的に行なわれます。同様にポインタを扱う必要もありません。コンパイラが必要に応じて暗黙のうちにポインタを導入します。
    </p>
    <p>
      他の大半のデータ構造の同じく、リストの中を見たり分解したりするのにはパターンマッチを用います。
      リストパターンはリスト式とまったく同じ形で、識別子でリストの未規定部分を表します。      
      
      例としてリストの挿入ソートを示します。 
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>let rec sort lst =
   match lst with
     [] -&gt; []
   | head :: tail -&gt; insert head (sort tail)
 and insert elt lst =
   match lst with
     [] -&gt; [elt]
   | head :: tail -&gt; if elt &lt;= head then elt :: lst else head :: insert elt tail
 ;;</code></strong>
<code class="computeroutput">val sort : 'a list -&gt; 'a list = &lt;fun&gt;
val insert : 'a -&gt; 'a list -&gt; 'a list = &lt;fun&gt;</code>

<code class="prompt">#</code><strong class="userinput"><code>sort l;;</code></strong>
<code class="computeroutput">- : string list = ["a"; "etc."; "is"; "tale"; "told"]</code>
    </pre>
    <p>
      <code class="code">sort</code> の型として推論された <code class="code">'a list -&gt; 'a list</code> は、 <code class="code">sort</code> は任意の型のリストでも引数にとれ、同じ型のリストを返すことを表しています。<code class="code">'a</code> は<span class="emphasis"><em>型変数</em></span>（type variable）で、任意の型を表します。<code class="code">sort</code> が任意の型のリストを受け取れるのは、Caml では比較演算子 (<code class="code">=</code>、<code class="code">&lt;=</code> など) が<span class="emphasis"><em>多相的</em></span>（polymorphic）であるためです。これらの演算子は同一の型を持つふたつの値に作用します。
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>sort [6;2;5;3];;</code></strong>
<code class="computeroutput">- : int list = [2; 3; 5; 6]</code>

<code class="prompt">#</code><strong class="userinput"><code>sort [3.14; 2.718];;</code></strong>
<code class="computeroutput">- : float list = [2.718; 3.14]</code>
    </pre>
   <p>
     上の <code class="code">sort</code> 関数は入力として与えられたリストを変更せず、入力されたリストと同じ要素を昇順に並べたリストを新たに作って返します。実際 Caml では、一度作ったリストを直接変更する方法はありません。このことを、リストは<span class="emphasis"><em>変更不能</em></span>（immutable）なデータ構造である、と言います。 Caml の大半のデータ構造は変更不能ですが、いくつかのデータ構造（有名なところでは配列）は<span class="emphasis"><em>変更可能</em></span>（mutable）で、いつでも直接変更することができます。
    </p>
  </div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch01s01.html">前のページ</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch01.html">上に戻る</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch01s03.html">次のページ</a></td></tr><tr><td width="40%" align="left" valign="top">1.1&nbsp;基本 &nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top">&nbsp;1.3&nbsp;値としての関数 </td></tr></table></div></body></html>