<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>18.8&nbsp;Advanced example with callbacks</title><link rel="stylesheet" href="css/stylesheet.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="The Objective Caml system release 3.12"><link rel="up" href="ch18.html" title="18.&nbsp;C と Objective Caml のインタフェース"><link rel="prev" href="ch18s07.html" title="18.7&nbsp;Advanced topic: callbacks from C to Caml"><link rel="next" href="ch18s09.html" title="18.9&nbsp;Advanced topic: custom blocks"></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">18.8&nbsp;Advanced example with callbacks</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch18s07.html">前のページ</a>&nbsp;</td><th width="60%" align="center">18.&nbsp;C と Objective Caml のインタフェース</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch18s09.html">次のページ</a></td></tr></table><hr></div><div class="section" title="18.8&nbsp;Advanced example with callbacks"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e13770"></a>18.8&nbsp;Advanced example with callbacks</h2></div></div></div>
    
    <p>
      This section illustrates the callback facilities described in section 18.7.
      We are going to package some Caml functions in such a way that they can be
      linked with C code and called from C just like any C functions. The Caml
      functions are defined in the following mod.ml Caml source:
    </p>
    <pre class="programlisting">
(* File mod.ml -- some ``useful'' Caml functions *)

let rec fib n = if n &lt; 2 then 1 else fib(n-1) + fib(n-2)

let format_result n = Printf.sprintf "Result is: %d\n" n

(* Export those two functions to C *)

let _ = Callback.register "fib" fib
let _ = Callback.register "format_result" format_result
</pre>
    <p>
      Here is the C stub code for calling these functions from C:
    </p>
    <pre class="programlisting">
/* File modwrap.c -- wrappers around the Caml functions */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;caml/mlvalues.h&gt;
#include &lt;caml/callback.h&gt;

int fib(int n)
{
  static value * fib_closure = NULL;
  if (fib_closure == NULL) fib_closure = caml_named_value("fib");
  return Int_val(caml_callback(*fib_closure, Val_int(n)));
}

char * format_result(int n)
{
  static value * format_result_closure = NULL;
  if (format_result_closure == NULL)
    format_result_closure = caml_named_value("format_result");
  return strdup(String_val(caml_callback(*format_result_closure, Val_int(n))));
  /* We copy the C string returned by String_val to the C heap
     so that it remains valid after garbage collection. */
}
</pre>
    <p>
      We now compile the Caml code to a C object file and put it in a C library
      along with the stub code in modwrap.c and the Caml runtime system: 
    </p>
    <pre class="programlisting">
ocamlc -custom -output-obj -o modcaml.o mod.ml
ocamlc -c modwrap.c
cp /usr/local/lib/ocaml/libcamlrun.a mod.a
ar r mod.a modcaml.o modwrap.o
</pre>
    <p>
      (One can also use ocamlopt -output-obj instead of ocamlc -custom -output-obj.
      In this case, replace libcamlrun.a (the bytecode runtime library) by
      libasmrun.a (the native-code runtime library).)
    </p>
    <p>
      Now, we can use the two functions fib and format_result in any C program,
      just like regular C functions. Just remember to call caml_startup once before.
    </p>
    <pre class="programlisting">
/* File main.c -- a sample client for the Caml functions */

#include &lt;stdio.h&gt;

int main(int argc, char ** argv)
{
  int result;

  /* Initialize Caml code */
  caml_startup(argv);
  /* Do some computation */
  result = fib(10);
  printf("fib(10) = %s\n", format_result(result));
  return 0;
}
</pre>
    <p>
      To build the whole program, just invoke the C compiler as follows: 
    </p>
    <pre class="programlisting">
cc -o prog main.c mod.a -lcurses
</pre>
    <p>
      (On some machines, you may need to put -ltermcap or -lcurses -ltermcap
      instead of -lcurses.)
    </p>
  </div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch18s07.html">前のページ</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch18.html">上に戻る</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch18s09.html">次のページ</a></td></tr><tr><td width="40%" align="left" valign="top">18.7&nbsp;Advanced topic: callbacks from C to Caml&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top">&nbsp;18.9&nbsp;Advanced topic: custom blocks</td></tr></table></div></body></html>