<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>3.12&nbsp;型変換の使用</title><link rel="stylesheet" href="css/stylesheet.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="The Objective Caml system release 3.12"><link rel="up" href="ch03.html" title="3.&nbsp;Caml におけるオブジェクト"><link rel="prev" href="ch03s11.html" title="3.11&nbsp;多相メソッド"><link rel="next" href="ch03s13.html" title="3.13&nbsp;関数型オブジェクト"></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3.12&nbsp;型変換の使用</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03s11.html">前のページ</a>&nbsp;</td><th width="60%" align="center">3.&nbsp;Caml におけるオブジェクト </th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch03s13.html">次のページ</a></td></tr></table><hr></div><div class="section" title="3.12&nbsp;型変換の使用"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Using coercions"></a>3.12&nbsp;型変換の使用</h2></div></div></div>
    
    <p>
      部分型関係が暗黙に導入されることは決してありません。部分型を導入する方法はふたつあります。もっとも汎用的な構文では、型変換の定義域と余定義域（訳注: 変換元と変換後の型）を完全に明示します。
    </p>
    <p>
      以前見たように、「点」と「色付きの点」は互換性のない型でした。例えば、この二つを同じリストの要素にすることはできません。しかし、「色付きの点」の <code class="code">color</code> メソッドを隠蔽すれば「点」に変換することができます。
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>let colored_point_to_point cp = (cp : colored_point :&gt; point);;</code></strong>
<code class="computeroutput">val colored_point_to_point : colored_point -&gt; point = &lt;fun&gt;</code>

<code class="prompt">#</code><strong class="userinput"><code>let p = new point 3 and q = new colored_point 4 "blue";;</code></strong>
<code class="computeroutput">val p : point = &lt;obj&gt;
val q : colored_point = &lt;obj&gt;</code>

<code class="prompt">#</code><strong class="userinput"><code>let l = [p; (colored_point_to_point q)];;</code></strong>
<code class="computeroutput">val l : point list = [&lt;obj&gt;; &lt;obj&gt;]</code>
    </pre>
    <p>
      型 <code class="code">t</code> のオブジェクトを型 <code class="code">t'</code> に見なすことができるのは、 <code class="code">t</code> が <code class="code">t'</code> の部分型であるときだけです。例えば、「点」を「色付きの点」に見なすことはできません。
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>(p : point :&gt; colored_point);;</code></strong>
<code class="computeroutput">Type point = &lt; get_offset : int; get_x : int; move : int -&gt; unit &gt;
is not a subtype of type
  colored_point =
    &lt; color : string; get_offset : int; get_x : int; move : int -&gt; unit &gt;</code>
    </pre>
    <p>
      実際、実行時の検査なしに型を狭い方向へ変換するのは安全ではないでしょう。実行時型検査で例外の発生する可能性もありますが、そのためには実行時にも型情報が必要になります。しかし、Objective Caml は実行時の型情報を持たないので、このような変換は行えません。
    </p>
    <p>
      部分型と継承とは何の関係もないことに注意して下さい。継承はクラス間の構文上の関係であり、部分型は型同士の意味上の関係なのです。例えば、「色付きの点」クラスは「点」クラスを継承せずに、直接定義することもできました。この場合でも「色付きの点」の型は変化せず、よって「点」の部分型になります。 
    </p>
    <p>
      変換前の型が省略することができることもあります。例えば、次のような定義は可能です。
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>let to_point cp = (cp :&gt; point);;</code></strong>
<code class="computeroutput">val to_point : #point -&gt; point = &lt;fun&gt;</code>
    </pre>
    <p>
      この場合、関数 <code class="code">colored_point_to_point</code> は関数 <code class="code">to_point</code> のインスタンスになっています。しかし、いつもそうだとは限りません。型変換前の型を明示する方がより正確ですし、変換前の型を省略できないこともあります。例えば、次のクラスを考えましょう。
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>class c0 = object method m = {&lt; &gt;} method n = 0 end;;</code></strong>
<code class="computeroutput">class c0 : object ('a) method m : 'a method n : int end</code>
    </pre>
    <p>
      型 <code class="code">c0</code> は <code class="code">&lt;m : 'a; n : int&gt; as 'a</code> の略記になります。ここで、次のようなクラス型を宣言を考えます。
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>class type c1 =  object method m : c1 end;;</code></strong>
<code class="computeroutput">class type c1 = object method m : c1 end</code>
    </pre>
    <p>
      型 <code class="code">c1 は &lt;m : 'a&gt; as 'a</code> の略記になります。型 <code class="code">c0</code> から <code class="code">c1</code> へ型変換は適正です。
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>fun (x:c0) -&gt; (x : c0 :&gt; c1);;</code></strong>
<code class="computeroutput">- : c0 -&gt; c1 = &lt;fun&gt;</code>
    </pre>
    <p>
      しかし、変換前の型を省略することはできせん。
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>fun (x:c0) -&gt; (x :&gt; c1);;</code></strong>
<code class="computeroutput">This expression cannot be coerced to type c1 = &lt; m : c1 &gt;; it has type
  c0 = &lt; m : c0; n : int &gt;
but is here used with type &lt; m : #c1 as 'a; .. &gt;
Type c0 = &lt; m : c0; n : int &gt; is not compatible with type 'a = &lt; m : c1; .. &gt;
Type c0 = &lt; m : c0; n : int &gt; is not compatible with type c1 = &lt; m : c1 &gt; 
The second object type has no method n.
This simple coercion was not fully general. Consider using a double coercion.</code>
    </pre>
    <p>
      この場合、変換前の型を明示する形式にする必要があります。場合によっては、クラス型の定義を変えることによってこの問題を解決できることもあります。
</p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>class type c2 =  object ('a) method m : 'a end;;</code></strong>
<code class="computeroutput">class type c2 = object ('a) method m : 'a end</code>

<code class="prompt">#</code><strong class="userinput"><code>fun (x:c0) -&gt; (x :&gt; c2);;</code></strong>
<code class="computeroutput">- : c0 -&gt; c2 = &lt;fun&gt;</code>x
    </pre>
    <p>
      <code class="code">c1</code> と <code class="code">c2</code> の別のクラス型ですが、オブジェクト型としては <code class="code">c1</code> と <code class="code">c2</code> は同一のオブジェクト型になります（同名の同一型のメソッドがあります）。しかし、もし変換前の型が省略され、変換後の型が既知のクラス型の略記であるときには、オブジェクト型ではなくクラス型が型変換関数を導出するのに用いられます。このために、子クラスから親クラスへの変換では、ほとんどの場合、変換前の型を明示定する必要がありません。型変換関数の型は次のようにして見ることができます。
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>let to_c1 x = (x :&gt; c1);;</code></strong>
<code class="computeroutput">val to_c1 : &lt; m : #c1; .. &gt; -&gt; c1 = &lt;fun&gt;</code>

<code class="prompt">#</code><strong class="userinput"><code>let to_c2 x = (x :&gt; c2);;</code></strong>
<code class="computeroutput">val to_c2 : #c2 -&gt; c2 = &lt;fun&gt;</code>
    </pre>
    <p>
      二つの型変換の違いに注目して下さい。 2つめの例では、（クラス型 <code class="code">c2</code> の定義で陽に再帰したことにより）型 <code class="code">#c2 = &lt; m : 'a; .. &gt; as 'a</code> は多相再帰的な型になっています。このため、<code class="code">c0</code> クラスのオブジェクトにも適応できます。一方、最初の例では、<code class="code">c1</code> は2回展開され、型 <code class="code">&lt; m : &lt; m : c1; .. &gt;; .. &gt;</code> になり、再帰的な型にはなりません（<code class="code">#c1 = &lt; m : c1; .. &gt;</code> です）。また、 <code class="code">to_c2</code> の型は <code class="code">#c2 -&gt; c2</code> であるのに対し、 <code class="code">to_c1</code> の型が <code class="code">#c1 -&gt; c1</code> よりも一般的であることに気づかれたかもしれません。しかし、<a class="xref" href="ch03s16.html" title="3.16&nbsp;バイナリメソッド"> 3.16 節「バイナリメソッド」</a>で説明するように、型 <code class="code">#c</code> のインスタンスが <code class="code">c</code> の子クラスにならないこともあるため、この型の方が常により一般的であると言えるわけではありません。それでも、パラメータ付きクラスでなければ、 <code class="code">(_ :&gt; c)</code> は <code class="code">(_ : #c :&gt; c)</code> より常に一般的です。 
    </p>
    <p>
      クラス <code class="code">c</code> の定義中にクラス <code class="code">c</code> への変換を定義しようとするとよく知られた問題に行き当たります。問題は、まだクラス <code class="code">c</code> に対する型略記が完全には定義されていないので、その部分型もはっきりとは分らないという点にあります。この場合、型変換 <code class="code">(_ :&gt; c)</code> や <code class="code">(_ : #c :&gt; c)</code> は次のように恒等関数と見なされます。
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>function x -&gt; (x :&gt; 'a);;</code></strong>
<code class="computeroutput">- : 'a -&gt; 'a = &lt;fun&gt;</code>
    </pre>
    <p>
      結果として、次のように、この型変換が <code class="code">self</code> に適用されると、 <code class="code">self</code> の型は閉じた型 <code class="code">c</code> になります（<code class="code">..</code> の付かないオブジェクト型を閉じたオブジェクト型と言います）。これは <code class="code">self</code> の型を閉じた型に制限するので、拒否されます。実際、 <code class="code">self</code> の型を閉じた型にすることはできません。閉じた型にすると、それ以降クラスを拡張することができなくなります。そのため、この型を他の型を同一化しようとすると閉じたオブジェクト型になってしまい、型エラーが発生します。
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>class c = object method m = 1 end
 and d = object (self)
   inherit c
   method n = 2
   method as_c = (self :&gt; c)
 end;;</code></strong>
<code class="computeroutput">This expression cannot be coerced to type c = &lt; m : int &gt;; it has type
  &lt; as_c : c; m : int; n : int; .. &gt;
but is here used with type c
Self type cannot be unified with a closed object type</code>
    </pre>
    <p>
      しかしこの問題の起こるもっとも一般的な例である、 <code class="code">self</code> を現在のクラスに型変換する場合は、型検査器が特別扱いをし、適切な型が与えられます。
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>class c = object (self) method m = (self :&gt; c) end;;
class c : object method m : c end</code></strong>
    </pre>
    <p>
      これを使うと、次のようにして、あるクラスやその子クラスに属するすべてオブジェクトのリスト保持することができます。
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>let all_c = ref [];;</code></strong>
<code class="computeroutput">val all_c : '_a list ref = {contents = []}</code>

<code class="prompt">#</code><strong class="userinput"><code>class c (m : int) =
   object (self)
     method m = m
     initializer all_c := (self :&gt; c) :: !all_c
   end;;</code></strong>
<code class="computeroutput">class c : int -&gt; object method m : int end</code>
    </pre>
    <p>
      これを用いると、型を <code class="code">c</code> に弱めた状態のオブジェクトを探索することができます。
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>let rec lookup_obj obj = function [] -&gt; raise Not_found
   | obj' :: l -&gt;
      if (obj :&gt; &lt; &gt;) = (obj' :&gt; &lt; &gt;) then obj' else lookup_obj obj l ;;</code></strong>
<code class="computeroutput">val lookup_obj : &lt; .. &gt; -&gt; (&lt; .. &gt; as 'a) list -&gt; 'a = &lt;fun&gt;</code>

#let lookup_c obj = lookup_obj obj !all_c;;
val lookup_c : &lt; .. &gt; -&gt; &lt; m : int &gt; = &lt;fun&gt;
    </pre>
    <p>
      型 <code class="code">&lt; m : int &gt;</code> は単に型 <code class="code">c</code> を展開したものです。これは参照を使ったためです。こうして型 <code class="code">c</code> のオブジェクトを取り出すことができました。
    </p>
    <p>
      先ほどの型変換の問題は、クラス型を使って最初に略記を定義しておくことで回避できることもままあります。
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>class type c' = object method m : int end;;</code></strong>
<code class="computeroutput">class type c' = object method m : int end</code>

<code class="prompt">#</code><strong class="userinput"><code>class c : c' = object method m = 1 end
 and d = object (self)
   inherit c
   method n = 2
   method as_c = (self :&gt; c')
 end;;</code></strong>
<code class="computeroutput">class c : c'
and d : object method as_c : c' method m : int method n : int endx</code>
    </pre>
    <p>
      また、抽象クラスを使うこともできます。このクラスから継承することによって、 <code class="code">c</code> のメソッドが <code class="code">c'</code> のメソッドと同じ型を持つことを保障することができます。
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>class virtual c' = object method virtual m : int end;;</code></strong>
<code class="computeroutput">class virtual c' : object method virtual m : int end</code>

<code class="prompt">#</code><strong class="userinput"><code>class c = object (self) inherit c' method m = 1 end;;</code></strong>
<code class="computeroutput">class c : object method m : int end</code>
    </pre>
    <p>
      型略記を直接定義しようと考える人もあるかもしれません。
    </p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>type c' = &lt;m : int&gt;;;</code></strong>
    </pre>
    <p>
      しかし、 <code class="code">#c'</code> という略記はこの方法では定義できず、クラス定義またはクラス型定義を介してしか定義できません。というのは、 <code class="code">#</code> 略記は暗黙の無名型変数 <code class="code">..</code> を持ち回るからです。この型変数に名前をつけることはできません。より近いのは、開いたオブジェクト型を捕捉する型変数を導入して次のようにすることです。
</p>
    <pre class="screen">
<code class="prompt">#</code><strong class="userinput"><code>type 'a c'_class = 'a constraint 'a = &lt; m : int; .. &gt;;;</code></strong>
    </pre>
  </div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03s11.html">前のページ</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch03.html">上に戻る</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch03s13.html">次のページ</a></td></tr><tr><td width="40%" align="left" valign="top">3.11&nbsp;多相メソッド&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top">&nbsp;3.13&nbsp;関数型オブジェクト</td></tr></table></div></body></html>